{"version":3,"sources":["applied_science/js_interop/destructure.cljc"],"mappings":"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","names":["applied-science.js-interop.destructure/dequote","x","cljs.core/list?","cljs.core._EQ_","cljs.core/first","cljs.core/second","applied-science.js-interop.destructure/dot-access?","cljs.core/Symbol","clojure.string/starts-with?","cljs.core/name","applied-science.js-interop.destructure/dot-access","s","cljs.core.symbol","clojure.string/replace-first","applied-science.js-interop.destructure/*js?*","applied-science.js-interop.destructure/destructure","bindings","bents","cljs.core.partition","pb","bvec","b","v","*js?*-orig-val__35454","*js?*-temp-val__35455","cljs.core/meta","pvec","gvec","cljs.core.gensym","gvec?","gseq","gfirst","has-rest","cljs.core/some","clj-rest?","and__4115__auto__","cljs.core/not","get-nth","n","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","get-rest","cljs.core/with-meta","ret","G__35477","cljs.core.conj","bs","seen-rest?","firstb","cljs.core/nnext","js/Error","cljs.core/next","pmap","gmap","defaults","bes","transforms","cljs.core.reduce","mk","cljs.core/Keyword","mkns","cljs.core/namespace","mkn","p1__35449#","cljs.core.assoc","cljs.core.keyword","or__4126__auto__","p1__35450#","cljs.core/str","cljs.core/keys","entry","p1__35451#","p2__35452#","fexpr__35492","cljs.core/val","cljs.core.dissoc","cljs.core/key","fexpr__35496","bb","bk","k","getf","local","cljs.core/PROTOCOL_SENTINEL","bv","cljs.core/contains?","cljs.core/vector?","cljs.core/map?","process-entry","cljs.core/every?","cljs.core/symbol?","cljs.core.map","temp__5733__auto__","kwbs","p1__35453#","cljs.core.filter","cljs.core/ffirst","cljs.spec.alpha/def-impl","cljs.spec.alpha/cat-impl","cljs.spec.alpha/and-spec-impl","cljs.spec.alpha.spec_impl","cljs.core/identity","cljs.core/vec","cljs.spec.alpha/rep-impl","cljs.core/any?","cljs.spec.alpha/alt-impl","cljs.spec.alpha/rep+impl","p1__35524#","cljs.spec.alpha/maybe-impl","applied-science.js-interop.destructure/spec-reform","spec","args","update-conf","cljs.spec.alpha/conform","G__35542","cljs.spec.alpha/unform","p__35544","map__35545","cljs.core.apply","cljs.core/hash-map","vec__35546","cljs.core.get","cljs.core.nth","applied-science.js-interop.destructure/update-argv+body","update-fn","arity","conf","update-pair","vec__35550","body-path","G__35553","params","body","G__35554","cljs.core.get_in","cljs.core/assoc-in","G__35575","cljs.core.update_in","p1__35543#","cljs.core.mapv","p__35580","vec__35581","applied-science.js-interop.destructure/maybe-destructured","new-params","lets","gparam","applied-science.js-interop.destructure/destructure-fn-args","p1__35595#"],"sourcesContent":["(ns applied-science.js-interop.destructure\n  (:refer-clojure :exclude [destructure])\n  (:require [clojure.string :as str]\n            [clojure.core :as c]\n            [clojure.spec.alpha :as s]))\n\n(defn- dequote [x]\n  (if (and (list? x) (= 'quote (first x)))\n    (second x)\n    x))\n\n(defn- dot-access? [x]\n  (and (symbol? x) (str/starts-with? (name x) \".-\")))\n\n(defn- dot-access [s]\n  (symbol (str/replace-first (name s) #\"^(?:\\.\\-)?\" \".-\")))\n\n(def ^:dynamic *js?* false)\n\n(c/defn destructure\n  \"Destructure with direct array and object access.\n\n  Invoked via ^:js metadata on binding form:\n\n  (let [^:js {:keys [a]} obj] ...)\n\n  Keywords compile to static keys, symbols to renamable keys,\n  and array access to `aget`.\"\n  [bindings]\n  ;; modified from cljs.core/destructure\n  (c/let [bents (partition 2 bindings)\n          pb (c/fn pb [bvec b v]\n               (binding [*js?* (cond (:clj (meta b)) false\n                                     *js?* true\n                                     :else (true? (:js (meta b))))]\n                 (c/let [pvec\n                         (c/fn [bvec b v]\n                           (c/let [gvec (gensym \"vec__\")\n                                   gvec? (gensym \"some_vec__\")\n                                   gseq (gensym \"seq__\")\n                                   gfirst (gensym \"first__\")\n                                   has-rest (some #{'&} b)\n                                   clj-rest? (and has-rest (not *js?*))\n                                   get-nth (fn [n]\n                                             (if *js?*\n                                               `(when ~gvec? (aget ~gvec ~n))\n                                               `(nth ~gvec ~n nil)))\n                                   get-rest (fn [n]\n                                              (if *js?*\n                                                `(some->\n                                                   ~(with-meta gvec {:tag 'array})\n                                                   (.slice ~n))\n                                                gseq))]\n                             (c/loop [ret (c/let [ret (cond-> (conj bvec gvec v)\n                                                              *js?* (conj gvec? `(some? ~gvec)))]\n                                            (if clj-rest?\n                                              (conj ret gseq (c/list `seq gvec))\n                                              ret))\n                                      n 0\n                                      bs b\n                                      seen-rest? false]\n                               (if (seq bs)\n                                 (c/let [firstb (first bs)]\n                                   (c/cond\n                                     (= firstb '&) (recur (pb ret (second bs) (get-rest n))\n                                                          n\n                                                          (nnext bs)\n                                                          true)\n                                     (= firstb :as) (pb ret (second bs) gvec)\n                                     :else (if seen-rest?\n                                             (throw #?(:clj  (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                       :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                             (recur (pb (if clj-rest?\n                                                          (conj ret\n                                                                gfirst `(first ~gseq)\n                                                                gseq `(next ~gseq))\n                                                          ret)\n                                                        firstb\n                                                        (if clj-rest?\n                                                          gfirst\n                                                          (get-nth n)))\n                                                    (c/inc n)\n                                                    (next bs)\n                                                    seen-rest?))))\n                                 ret))))\n                         pmap\n                         (c/fn [bvec b v]\n                           (c/let [gmap (gensym \"map__\")\n                                   defaults (:or b)]\n                             (c/loop [ret (c/-> bvec (conj gmap) (conj v)\n                                                (conj gmap) (conj `(if (~'cljs.core/implements? c/ISeq ~gmap) (apply cljs.core/hash-map ~gmap) ~gmap))\n                                                ((c/fn [ret]\n                                                   (if (:as b)\n                                                     (conj ret (:as b) gmap)\n                                                     ret))))\n                                      bes (c/let [transforms\n                                                  (reduce\n                                                    (c/fn [transforms mk]\n                                                      (if (c/keyword? mk)\n                                                        (c/let [mkns (namespace mk)\n                                                                mkn (name mk)]\n                                                          (c/cond (= mkn \"keys\") (assoc transforms mk #(keyword (c/or mkns (namespace %)) (name %)))\n                                                                  (= mkn \"syms\") (assoc transforms mk #(c/list `quote (symbol (c/or mkns (namespace %)) (name %))))\n                                                                  (= mkn \"strs\") (assoc transforms mk c/str)\n                                                                  :else transforms))\n                                                        transforms))\n                                                    {}\n                                                    (keys b))]\n                                            (reduce\n                                              (c/fn [bes entry]\n                                                (reduce #(assoc %1 %2 ((val entry) %2))\n                                                        (dissoc bes (key entry))\n                                                        ((key entry) bes)))\n                                              (dissoc b :as :or)\n                                              transforms))]\n                               (if (seq bes)\n                                 (c/let [bb (key (first bes))\n                                         bk (val (first bes))\n\n                                         ;; convert renamable keys to .-dotFormat\n                                         bk (let [k (dequote bk)]\n                                              (if (and *js?* (symbol? k))\n                                                (dot-access k)\n                                                bk))\n                                         ;; use js-interop for ^js-tagged bindings & other renamable keys\n                                         getf (if *js?*\n                                                'applied-science.js-interop/get\n                                                'cljs.core/get)\n\n                                         local (if #?(:clj  (c/instance? clojure.lang.Named bb)\n                                                      :cljs (cljs.core/implements? INamed bb))\n                                                 (with-meta (symbol nil (name bb)) (meta bb))\n                                                 bb)\n                                         bv (if (contains? defaults local)\n                                              (c/list getf gmap bk (defaults local))\n                                              (c/list getf gmap bk))]\n                                   (recur\n                                     (if (c/or (c/keyword? bb) (c/symbol? bb)) ;(ident? bb)\n                                       (c/-> ret (conj local bv))\n                                       (pb ret bb bv))\n                                     (next bes)))\n                                 ret))))]\n                   (c/cond\n                     (c/symbol? b) (c/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                     (c/keyword? b) (c/-> bvec (conj (symbol (name b))) (conj v))\n                     (vector? b) (pvec bvec b v)\n                     (map? b) (pmap bvec b v)\n                     :else (throw\n                             #?(:clj  (new Exception (c/str \"Unsupported binding form: \" b))\n                                :cljs (new js/Error (c/str \"Unsupported binding form: \" b))))))))\n          process-entry (c/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? c/symbol? (map first bents))\n      bindings\n      (c/if-let [kwbs (seq (filter #(c/keyword? (first %)) bents))]\n        (throw\n          #?(:clj  (new Exception (c/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (c/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Function argument parsing\n\n(s/def ::argv+body\n  (s/cat :params (s/and\n                   vector?\n                   (s/conformer identity vec)\n                   (s/cat :params (s/* any?)))\n         :body (s/alt :prepost+body (s/cat :prepost map?\n                                           :body (s/+ any?))\n                      :body (s/* any?))))\n\n(s/def ::function-args\n  (s/cat :fn-prelude (s/* #(and (not (vector? %)) (not (list? %))))\n         :fn-tail (s/alt :arity-1 ::argv+body\n                         :arity-n (s/cat :bodies (s/+ (s/spec ::argv+body))\n                                         :attr-map (s/? map?)))))\n\n(c/defn- spec-reform [spec args update-conf]\n  (->> (s/conform spec args)\n       (update-conf)\n       (s/unform spec)))\n\n(c/defn- update-argv+body [update-fn {[arity] :fn-tail :as conf}]\n  (let [update-pair\n        (fn [conf]\n          (let [body-path (cond-> [:body 1]\n                                  (= :prepost+body (first (:body conf))) (conj :body))\n                [params body] (update-fn [(get-in conf [:params :params])\n                                          (get-in conf body-path)])]\n            (-> conf\n                (assoc-in [:params :params] params)\n                (assoc-in body-path body))))]\n    (case arity\n      :arity-1 (update-in conf [:fn-tail 1] update-pair)\n      :arity-n (update-in conf [:fn-tail 1 :bodies] #(mapv update-pair %)))))\n\n(c/defn- maybe-destructured\n  [[params body]]\n  (if (every? symbol? params)\n    [params body]\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (c/let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (conj lets (first params) gparam))))\n        [new-params\n         `[(~'applied-science.js-interop/let ~lets\n             ~@body)]]))))\n\n(c/defn destructure-fn-args [args]\n  (spec-reform ::function-args args #(update-argv+body maybe-destructured %)))\n"]}
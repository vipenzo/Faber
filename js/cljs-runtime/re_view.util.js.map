{"version":3,"sources":["re_view/util.cljc"],"mappings":"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","names":["re-view.util/camelCase","cljs.core/memoize","s","clojure.string/replace","cljs.core/name","p__52154","vec__52156","cljs.core.nth","_","match","clojure.string/upper-case","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","re-view.util/update-attrs","seq52160","G__52161","cljs.core/first","cljs.core/next","G__52162","self__4723__auto__","el","f","args","cljs.core/vector?","attrs?","cljs.core/map?","cljs.core/second","cljs.core.into","cljs.core.apply","cljs.core.subvec","re-view.util/ensure-keys","forms","seen","p1__52168#","p2__52167#","cljs.core.map_indexed","re_view.util.update_attrs","cljs.core/update","k","cljs.core/contains?","cljs.core.swap_BANG_","cljs.core/conj","re-view.util/map-with-keys","seq52172","self__4724__auto__","cljs.core/seq","cljs.core/map","re-view.util/any-pred","seq52174","fns","this","cljs.core/empty?","or__4126__auto__","fexpr__52176","cljs.core/rest","re-view.util/is-react-element?","x","and__4115__auto__","js/module$node_modules$react$index.isValidElement","re-view.util/flatten-seqs","children","p1__52177#","cljs.core.filter","cljs.core/seq?","cljs.core/tree-seq","re-view.util/parse-opt-args","preds","out","cljs.core.conj","match?","G__52187","fexpr__52186","G__52188"],"sourcesContent":["(ns re-view.util\n  (:refer-clojure :exclude [uuid])\n  (:require [clojure.string :as string]\n            #?@(:cljs [[\"react\" :as react]\n                       [re-db.d :as d]])))\n\n(def camelCase\n  \"Return camelCased string, eg. hello-there to helloThere. Does not modify existing case.\"\n  (memoize\n    (fn [s]\n      (string/replace (name s) #\"-(.)\" (fn [[_ match]] (string/upper-case match))))))\n\n\n(defn update-attrs [el f & args]\n  (if-not (vector? el)\n    el\n    (let [attrs? (map? (second el))]\n      (into [(el 0) (apply f (if attrs? (el 1) {}) args)]\n            (subvec el (if attrs? 2 1))))))\n\n(defn ensure-keys [forms]\n  (let [seen #{}]\n    (map-indexed #(update-attrs %2 update :key (fn [k]\n                                                       (if (or (nil? k) (contains? seen k))\n                                                         %1\n                                                         (do (swap! seen conj k)\n                                                             k)))) forms)))\n\n(defn map-with-keys [& args]\n  (ensure-keys (apply clojure.core/map args)))\n\n(defn any-pred\n  \"Evaluate fns sequentially, stopping if any return true.\"\n  [& fns]\n  (fn [this]\n    (loop [fns fns]\n      (if (empty? fns)\n        false\n        (or ((first fns) this)\n            (recur (rest fns)))))))\n\n#?(:cljs (defn is-react-element? [x]\n           (and x (react/isValidElement x))))\n\n(defn flatten-seqs\n  \"Flatten collection, only unwrap sequences\"\n  [children]\n  (filter #(not (seq? %))\n          (rest (tree-seq seq? seq children))))\n\n(defn parse-opt-args [preds args]\n  (loop [preds preds\n         args args\n         out []]\n    (if (empty? preds)\n      (conj out args)\n      (let [match? ((first preds) (first args))]\n        (recur (rest preds)\n               (cond-> args match? (rest))\n               (conj out (if match? (first args) nil)))))))"]}
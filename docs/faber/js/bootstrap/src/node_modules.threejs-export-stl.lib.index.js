shadow$provide["module$node_modules$threejs_export_stl$lib$index"] = function(global,require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mimeType = undefined;
exports.fromGeometry = fromGeometry;
exports.fromMesh = fromMesh;

var _three = require('three');

var mimeType = exports.mimeType = 'application/vnd.ms-pki.stl';

var LITTLE_ENDIAN = true;

function writeVectorAscii(dataView, _ref, isNormal) {
  var x = _ref.x,
      y = _ref.y,
      z = _ref.z;

  dataView.data += (isNormal ? 'facet normal' : 'vertex') + ' ' + x + ' ' + y + ' ' + z + '\n';
}

function writeVectorBinary(dataView, _ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      z = _ref2.z;

  writeFloat(dataView, x);
  writeFloat(dataView, y);
  writeFloat(dataView, z);
}

function writeFloat(dataView, float) {
  dataView.data.setFloat32(dataView.offset, float, LITTLE_ENDIAN);
  dataView.offset += 4;
}

function geometryToData(geometry, binary) {
  var faces = geometry.faces;
  var vertices = geometry.vertices;

  var dataView = void 0;
  if (binary) {
    var bufferSize = 84 + 50 * faces.length;
    var buffer = new ArrayBuffer(bufferSize);
    dataView = {
      data: new DataView(buffer),
      offset: 84
    };

    dataView.data.setUint32(80, faces.length, LITTLE_ENDIAN);
  } else {
    dataView = { data: 'solid\n' };
  }

  var writeVector = binary ? writeVectorBinary : writeVectorAscii;

  for (var i = 0; i < faces.length; i++) {
    writeVector(dataView, faces[i].normal, true);

    if (!binary) {
      dataView.data += 'outer loop\n';
    }

    writeVector(dataView, vertices[faces[i].a], false);
    writeVector(dataView, vertices[faces[i].b], false);
    writeVector(dataView, vertices[faces[i].c], false);

    if (binary) {
      dataView.offset += 2;
    } else {
      dataView.data += 'endloop\nendfacet\n';
    }
  }

  if (!binary) {
    dataView.data += 'endsolid';
  }

  return binary ? dataView.data.buffer : dataView.data;
}

function fromGeometry(geometry, matrix) {
  var binary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (geometry.isBufferGeometry) {
    geometry = new _three.Geometry().fromBufferGeometry(geometry);
  } else if (geometry.isGeometry) {
    geometry = geometry.clone();
  } else {
    throw new Error('Geometry is not an instance of BufferGeometry or Geometry');
  }

  if (matrix && matrix.isMatrix4) {
    geometry.applyMatrix(matrix);
  }

  geometry.computeFaceNormals();

  return geometryToData(geometry, binary);
}

function fromMesh(mesh, binary) {
  mesh.updateMatrix();

  return fromGeometry(mesh.geometry, mesh.matrix, binary);
}
//# sourceMappingURL=index.js.map
};
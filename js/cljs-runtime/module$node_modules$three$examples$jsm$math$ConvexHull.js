shadow$provide.module$node_modules$three$examples$jsm$math$ConvexHull=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.ConvexHull=void 0;var _threeModule=require("module$node_modules$three$build$three_module");global=function(){function ConvexHull(){this.tolerance=-1;this.faces=[];this.newFaces=[];this.assigned=new VertexList;this.unassigned=new VertexList;this.vertices=[]}function Face(){this.normal=new _threeModule.Vector3;this.midpoint=new _threeModule.Vector3;
this.constant=this.area=0;this.outside=null;this.mark=0;this.edge=null}function HalfEdge(vertex,face){this.vertex=vertex;this.twin=this.next=this.prev=null;this.face=face}function VertexNode(point){this.point=point;this.face=this.next=this.prev=null}function VertexList(){this.tail=this.head=null}var v1=new _threeModule.Vector3;Object.assign(ConvexHull.prototype,{setFromPoints:function(points){!0!==Array.isArray(points)&&console.error("THREE.ConvexHull: Points parameter is not an array.");4>points.length&&
console.error("THREE.ConvexHull: The algorithm needs at least four points.");this.makeEmpty();for(var i=0,l=points.length;i<l;i++)this.vertices.push(new VertexNode(points[i]));this.compute();return this},setFromObject:function(object){var points=[];object.updateMatrixWorld(!0);object.traverse(function(node){var l;var i=node.geometry;if(void 0!==i)if(i.isGeometry){var vertices=i.vertices;i=0;for(l=vertices.length;i<l;i++){var point=vertices[i].clone();point.applyMatrix4(node.matrixWorld);points.push(point)}}else if(i.isBufferGeometry&&
(vertices=i.attributes.position,void 0!==vertices))for(i=0,l=vertices.count;i<l;i++)point=new _threeModule.Vector3,point.fromBufferAttribute(vertices,i).applyMatrix4(node.matrixWorld),points.push(point)});return this.setFromPoints(points)},containsPoint:function(point){for(var faces=this.faces,i=0,l=faces.length;i<l;i++)if(faces[i].distanceToPoint(point)>this.tolerance)return!1;return!0},intersectRay:function(ray,target){for(var faces=this.faces,tNear=-Infinity,tFar=Infinity,i=0,l=faces.length;i<
l;i++){var face=faces[i],vN=face.distanceToPoint(ray.origin);face=face.normal.dot(ray.direction);if(0<vN&&0<=face)return null;vN=0!==face?-vN/face:0;if(!(0>=vN)&&(0<face?tFar=Math.min(vN,tFar):tNear=Math.max(vN,tNear),tNear>tFar))return null}-Infinity!==tNear?ray.at(tNear,target):ray.at(tFar,target);return target},intersectsRay:function(ray){return null!==this.intersectRay(ray,v1)},makeEmpty:function(){this.faces=[];this.vertices=[];return this},addVertexToFace:function(vertex,face){vertex.face=face;
null===face.outside?this.assigned.append(vertex):this.assigned.insertBefore(face.outside,vertex);face.outside=vertex;return this},removeVertexFromFace:function(vertex,face){vertex===face.outside&&(face.outside=null!==vertex.next&&vertex.next.face===face?vertex.next:null);this.assigned.remove(vertex);return this},removeAllVerticesFromFace:function(face){if(null!==face.outside){for(var start=face.outside,end=face.outside;null!==end.next&&end.next.face===face;)end=end.next;this.assigned.removeSubList(start,
end);start.prev=end.next=null;face.outside=null;return start}},deleteFaceVertices:function(face,absorbingFace){face=this.removeAllVerticesFromFace(face);if(void 0!==face)if(void 0===absorbingFace)this.unassigned.appendChain(face);else{do{var nextVertex=face.next;absorbingFace.distanceToPoint(face.point)>this.tolerance?this.addVertexToFace(face,absorbingFace):this.unassigned.append(face);face=nextVertex}while(null!==face)}return this},resolveUnassignedPoints:function(newFaces){if(!1===this.unassigned.isEmpty()){var vertex=
this.unassigned.first();do{for(var nextVertex=vertex.next,maxDistance=this.tolerance,maxFace=null,i=0;i<newFaces.length;i++){var face=newFaces[i];if(0===face.mark){var distance=face.distanceToPoint(vertex.point);distance>maxDistance&&(maxDistance=distance,maxFace=face);if(maxDistance>1E3*this.tolerance)break}}null!==maxFace&&this.addVertexToFace(vertex,maxFace);vertex=nextVertex}while(null!==vertex)}return this},computeExtremes:function(){var min=new _threeModule.Vector3,max=new _threeModule.Vector3,
minVertices=[],maxVertices=[],i,l,j;for(i=0;3>i;i++)minVertices[i]=maxVertices[i]=this.vertices[0];min.copy(this.vertices[0].point);max.copy(this.vertices[0].point);i=0;for(l=this.vertices.length;i<l;i++){var vertex=this.vertices[i],point=vertex.point;for(j=0;3>j;j++)point.getComponent(j)<min.getComponent(j)&&(min.setComponent(j,point.getComponent(j)),minVertices[j]=vertex);for(j=0;3>j;j++)point.getComponent(j)>max.getComponent(j)&&(max.setComponent(j,point.getComponent(j)),maxVertices[j]=vertex)}this.tolerance=
3*Number.EPSILON*(Math.max(Math.abs(min.x),Math.abs(max.x))+Math.max(Math.abs(min.y),Math.abs(max.y))+Math.max(Math.abs(min.z),Math.abs(max.z)));return{min:minVertices,max:maxVertices}},computeInitialHull:function(){var line3,plane,closestPoint;return function(){void 0===line3&&(line3=new _threeModule.Line3,plane=new _threeModule.Plane,closestPoint=new _threeModule.Vector3);var vertices=this.vertices,extremes=this.computeExtremes(),min=extremes.min,max=extremes.max,l,j,maxDistance=0;for(extremes=
j=0;3>extremes;extremes++){var distance=max[extremes].point.getComponent(extremes)-min[extremes].point.getComponent(extremes);distance>maxDistance&&(maxDistance=distance,j=extremes)}min=min[j];max=max[j];maxDistance=0;line3.set(min.point,max.point);extremes=0;for(l=this.vertices.length;extremes<l;extremes++){var vertex=vertices[extremes];if(vertex!==min&&vertex!==max&&(line3.closestPointToPoint(vertex.point,!0,closestPoint),distance=closestPoint.distanceToSquared(vertex.point),distance>maxDistance)){maxDistance=
distance;var v2=vertex}}maxDistance=-1;plane.setFromCoplanarPoints(min.point,max.point,v2.point);extremes=0;for(l=this.vertices.length;extremes<l;extremes++)if(vertex=vertices[extremes],vertex!==min&&vertex!==max&&vertex!==v2&&(distance=Math.abs(plane.distanceToPoint(vertex.point)),distance>maxDistance)){maxDistance=distance;var v3=vertex}distance=[];if(0>plane.distanceToPoint(v3.point))for(distance.push(Face.create(min,max,v2),Face.create(v3,max,min),Face.create(v3,v2,max),Face.create(v3,min,v2)),
extremes=0;3>extremes;extremes++)j=(extremes+1)%3,distance[extremes+1].getEdge(2).setTwin(distance[0].getEdge(j)),distance[extremes+1].getEdge(1).setTwin(distance[j+1].getEdge(0));else for(distance.push(Face.create(min,v2,max),Face.create(v3,min,max),Face.create(v3,max,v2),Face.create(v3,v2,min)),extremes=0;3>extremes;extremes++)j=(extremes+1)%3,distance[extremes+1].getEdge(2).setTwin(distance[0].getEdge((3-extremes)%3)),distance[extremes+1].getEdge(0).setTwin(distance[j+1].getEdge(1));for(extremes=
0;4>extremes;extremes++)this.faces.push(distance[extremes]);extremes=0;for(l=vertices.length;extremes<l;extremes++)if(vertex=vertices[extremes],vertex!==min&&vertex!==max&&vertex!==v2&&vertex!==v3){maxDistance=this.tolerance;var maxFace=null;for(j=0;4>j;j++)distance=this.faces[j].distanceToPoint(vertex.point),distance>maxDistance&&(maxDistance=distance,maxFace=this.faces[j]);null!==maxFace&&this.addVertexToFace(vertex,maxFace)}return this}}(),reindexFaces:function(){for(var activeFaces=[],i=0;i<this.faces.length;i++){var face=
this.faces[i];0===face.mark&&activeFaces.push(face)}this.faces=activeFaces;return this},nextVertexToAdd:function(){if(!1===this.assigned.isEmpty()){var maxDistance=0,eyeFace=this.assigned.first().face,vertex=eyeFace.outside;do{var distance=eyeFace.distanceToPoint(vertex.point);if(distance>maxDistance){maxDistance=distance;var eyeVertex=vertex}vertex=vertex.next}while(null!==vertex&&vertex.face===eyeFace);return eyeVertex}},computeHorizon:function(eyePoint,crossEdge,face,horizon){this.deleteFaceVertices(face);
face.mark=1;face=null===crossEdge?crossEdge=face.getEdge(0):crossEdge.next;do{var twinEdge=face.twin,oppositeFace=twinEdge.face;0===oppositeFace.mark&&(oppositeFace.distanceToPoint(eyePoint)>this.tolerance?this.computeHorizon(eyePoint,twinEdge,oppositeFace,horizon):horizon.push(face));face=face.next}while(face!==crossEdge);return this},addAdjoiningFace:function(eyeVertex,horizonEdge){eyeVertex=Face.create(eyeVertex,horizonEdge.tail(),horizonEdge.head());this.faces.push(eyeVertex);eyeVertex.getEdge(-1).setTwin(horizonEdge.twin);
return eyeVertex.getEdge(0)},addNewFaces:function(eyeVertex,horizon){this.newFaces=[];for(var firstSideEdge=null,previousSideEdge=null,i=0;i<horizon.length;i++){var sideEdge=this.addAdjoiningFace(eyeVertex,horizon[i]);null===firstSideEdge?firstSideEdge=sideEdge:sideEdge.next.setTwin(previousSideEdge);this.newFaces.push(sideEdge.face);previousSideEdge=sideEdge}firstSideEdge.next.setTwin(previousSideEdge);return this},addVertexToHull:function(eyeVertex){var horizon=[];this.unassigned.clear();this.removeVertexFromFace(eyeVertex,
eyeVertex.face);this.computeHorizon(eyeVertex.point,null,eyeVertex.face,horizon);this.addNewFaces(eyeVertex,horizon);this.resolveUnassignedPoints(this.newFaces);return this},cleanup:function(){this.assigned.clear();this.unassigned.clear();this.newFaces=[];return this},compute:function(){var vertex;for(this.computeInitialHull();void 0!==(vertex=this.nextVertexToAdd());)this.addVertexToHull(vertex);this.reindexFaces();this.cleanup();return this}});Object.assign(Face,{create:function(a,b,c){var face=
new Face;a=new HalfEdge(a,face);b=new HalfEdge(b,face);c=new HalfEdge(c,face);a.next=c.prev=b;b.next=a.prev=c;c.next=b.prev=a;face.edge=a;return face.compute()}});Object.assign(Face.prototype,{getEdge:function(i){for(var edge=this.edge;0<i;)edge=edge.next,i--;for(;0>i;)edge=edge.prev,i++;return edge},compute:function(){var triangle;return function(){void 0===triangle&&(triangle=new _threeModule.Triangle);var a=this.edge.tail(),b=this.edge.head(),c=this.edge.next.head();triangle.set(a.point,b.point,
c.point);triangle.getNormal(this.normal);triangle.getMidpoint(this.midpoint);this.area=triangle.getArea();this.constant=this.normal.dot(this.midpoint);return this}}(),distanceToPoint:function(point){return this.normal.dot(point)-this.constant}});Object.assign(HalfEdge.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var head=this.head(),tail=this.tail();return null!==tail?tail.point.distanceTo(head.point):-1},lengthSquared:function(){var head=
this.head(),tail=this.tail();return null!==tail?tail.point.distanceToSquared(head.point):-1},setTwin:function(edge){this.twin=edge;edge.twin=this;return this}});Object.assign(VertexList.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){this.head=this.tail=null;return this},insertBefore:function(target,vertex){vertex.prev=target.prev;vertex.next=target;null===vertex.prev?this.head=vertex:vertex.prev.next=vertex;target.prev=vertex;return this},insertAfter:function(target,
vertex){vertex.prev=target;vertex.next=target.next;null===vertex.next?this.tail=vertex:vertex.next.prev=vertex;target.next=vertex;return this},append:function(vertex){null===this.head?this.head=vertex:this.tail.next=vertex;vertex.prev=this.tail;vertex.next=null;this.tail=vertex;return this},appendChain:function(vertex){null===this.head?this.head=vertex:this.tail.next=vertex;for(vertex.prev=this.tail;null!==vertex.next;)vertex=vertex.next;this.tail=vertex;return this},remove:function(vertex){null===
vertex.prev?this.head=vertex.next:vertex.prev.next=vertex.next;null===vertex.next?this.tail=vertex.prev:vertex.next.prev=vertex.prev;return this},removeSubList:function(a,b){null===a.prev?this.head=b.next:a.prev.next=b.next;null===b.next?this.tail=a.prev:b.next.prev=a.prev;return this},isEmpty:function(){return null===this.head}});return ConvexHull}();exports.ConvexHull=global}
//# sourceMappingURL=module$node_modules$three$examples$jsm$math$ConvexHull.js.map

["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","cells/cell$macros.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",15],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$cells.cell$macros","~:imports",null,"~:requires",["^ ","~$cells.util","^B","~$util","^B","~$cljs.core","^D","~$goog","^E"],"~:seen",["^=",["~:require"]],"~:shadow/js-access-global",["^=",["Error"]],"~:uses",null,"~:defs",["^ ","~$lib-bindings",["^ ","^>","~$cells.cell$macros/lib-bindings","^3","cells/cell$macros.cljc","^4",4,"^5",1,"^6",4,"^7",18,"^2",["^ ","^3","cells/cell$macros.cljc","^4",4,"^5",6,"^6",4,"^7",18],"~:tag",["^=",[null,"~$any"]]],"~$defcell",["^ ","~:protocol-inline",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",18,"~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",1,"~:max-fixed-arity",1,"~:method-params",["~#list",[["^V",["~$the-name","~$body"]]]],"~:arglists",["^V",[["^W","~$&","^X"]]],"~:arglists-meta",["^V",[null]]],"^5",11,"^4",12,"~:macro",true,"^6",12,"^Y",["^V",["~$quote",["^V",[["^W","~$&","^X"]]]]],"~:doc","Defines a named cell."],"^>","~$cells.cell$macros/defcell","^3","cells/cell$macros.cljc","^7",18,"^Q",["^ ","^R",true,"^S",1,"^T",1,"^U",["^V",[["^V",["^W","^X"]]]],"^Y",["^V",[["^W","~$&","^X"]]],"^Z",["^V",[null]]],"^U",["^V",[["^V",["^W","^X"]]]],"~:protocol-impl",null,"^S",1,"^Z",["^V",[null]],"^5",1,"^R",true,"~:methods",[["^ ","^S",1,"^R",true,"^M",["^=",["~$seq","~$cljs.core/IList"]]]],"^4",12,"^[",true,"~:ret-tag","^N","^6",12,"^T",1,"~:fn-var",false,"^Y",["^V",[["^W","~$&","^X"]]],"^11","Defines a named cell."],"~$cell-name",["^ ","^P",null,"^2",["^ ","^3","cells/cell$macros.cljc","^4",24,"^5",8,"^6",24,"^7",17,"~:private",true,"^Y",["^V",["^10",["^V",[["~$key"]]]]],"^11","Construct a cell-name, incorporating the runtime-value of `key` if provided."],"^1:",true,"^>","~$cells.cell$macros/cell-name","^3","cells/cell$macros.cljc","^7",17,"^U",["^V",[["^1;"]]],"^13",null,"^Z",["^V",[null,null]],"^5",1,"^R",false,"^4",24,"^17",["^=",["^15","^16","~$cljs.core/Keyword"]],"^6",24,"^T",1,"^18",true,"^Y",["^V",["^10",["^V",[["^1;"]]]]],"^11","Construct a cell-name, incorporating the runtime-value of `key` if provided."],"~$cell",["^ ","^P",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",15,"^Q",["^ ","^R",false,"^S",2,"^T",2,"^U",["^V",[["~$expr"],["^1;","^1?"]]],"^Y",["^V",[["^1?"],["^1;","^1?"]]],"^Z",["^V",[null,null]]],"^5",11,"^4",32,"^[",true,"^6",32,"^Y",["^V",["^10",["^V",[["^1?"],["^1;","^1?"]]]]],"^11","Returns an anonymous cell. Only one cell will be returned per lexical instance of `cell`,\n  unless a unique `key` is provided. Helper functions in `lib-bindings` (eg. interval) are\n  hoisted into scope, as is `self`, which refers to the current cell."],"^>","~$cells.cell$macros/cell","^3","cells/cell$macros.cljc","^7",15,"^Q",["^ ","^R",false,"^S",2,"^T",2,"^U",["^V",[["^1?"],["^1;","^1?"]]],"^Y",["^V",[["^1?"],["^1;","^1?"]]],"^Z",["^V",[null,null]]],"^U",["^V",[["^1?"],["^1;","^1?"]]],"^13",null,"^S",2,"^Z",["^V",[null,null]],"^5",1,"^R",false,"^14",[["^ ","^S",3,"^R",false,"^M",["^=",["^15","^16"]]],["^ ","^S",4,"^R",false,"^M",["^=",["^15","^16"]]]],"^4",32,"^[",true,"^6",32,"^T",2,"^18",false,"^Y",["^V",[["^1?"],["^1;","^1?"]]],"^11","Returns an anonymous cell. Only one cell will be returned per lexical instance of `cell`,\n  unless a unique `key` is provided. Helper functions in `lib-bindings` (eg. interval) are\n  hoisted into scope, as is `self`, which refers to the current cell."],"~$cell-fn",["^ ","^P",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",18,"^Q",["^ ","^R",true,"^S",0,"^T",0,"^U",["^V",[["^V",["^X"]]]],"^Y",["^V",[["~$&","^X"]]],"^Z",["^V",[null]]],"^5",11,"^4",42,"^[",true,"^6",42,"^Y",["^V",["^10",["^V",[["~$&","^X"]]]]],"^11","Returns an anonymous function which will evaluate with the current cell in the stack.\n  Similar to Clojure's `bound-fn`, but only cares about the currently bound cell."],"^>","~$cells.cell$macros/cell-fn","^3","cells/cell$macros.cljc","^7",18,"^Q",["^ ","^R",true,"^S",0,"^T",0,"^U",["^V",[["^V",["^X"]]]],"^Y",["^V",[["~$&","^X"]]],"^Z",["^V",[null]]],"^U",["^V",[["^V",["^X"]]]],"^13",null,"^S",0,"^Z",["^V",[null]],"^5",1,"^R",true,"^14",[["^ ","^S",0,"^R",true,"^M",["^=",["^15","^16"]]]],"^4",42,"^[",true,"^17","^N","^6",42,"^T",0,"^18",false,"^Y",["^V",[["~$&","^X"]]],"^11","Returns an anonymous function which will evaluate with the current cell in the stack.\n  Similar to Clojure's `bound-fn`, but only cares about the currently bound cell."]],"~:require-macros",["^ ","^D","^D"],"~:cljs.analyzer/constants",["^ ","^F",["^=",["~$&","~$cells.cell/cell*","~$the-cell__52952__auto__","~$cljs.core/keyword","~$cljs.core/str","~$try","~$cljs.core/binding","~$cells.cell/*eval-context*","~$cells.cell/cell","~$self","~$args__52954__auto__","~$cljs.core/hash","~$cljs.core/apply","~$cells.eval-context/handle-error","~$cells.lib/timeout","~$cells.lib/fetch","~$error__52955__auto__","~$cljs.core/let","~$cells.cell/*cell-stack*","~$cljs.core/fn","~$cells.lib/interval","~$cljs.core/cons","~$catch","~$cljs.core/first","~$js/Error","~$def","~$context__52953__auto__"]],"~:order",["^1X","^1R","^1S","^21","^1U","^1E","^1W","^1M","^1G","^1H","^1O","^1L","^1F","^1[","^1V","^22","^1K","~$&","^1N","^1J","^1Y","^1I","^1P","^1Z","^20","^1T","^1Q"]],"~:flags",["^ ","^G",["^=",[]]],"~:js-deps",["^ "],"~:deps",["^E","^D","^B"]]
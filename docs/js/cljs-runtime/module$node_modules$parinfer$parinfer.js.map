{
"version":3,
"file":"module$node_modules$parinfer$parinfer.js",
"lineCount":38,
"mappings":"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",
"sources":["node_modules/parinfer/parinfer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$parinfer$parinfer\"] = function(global,require,module,exports) {\n//\n// Parinfer 3.12.0\n//\n// Copyright 2015-2017 \u00a9 Shaun Lebron\n// MIT License\n//\n// Home Page: http://shaunlebron.github.io/parinfer/\n// GitHub: https://github.com/shaunlebron/parinfer\n//\n// For DOCUMENTATION on this file, please see `doc/code.md`.\n// Use `sync.sh` to keep the function/var links in `doc/code.md` accurate.\n//\n\n//------------------------------------------------------------------------------\n// JS Module Boilerplate\n//------------------------------------------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  }\n  else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  }\n  else {\n    root.parinfer = factory();\n  }\n}(this, function() { // start module anonymous scope\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants / Predicates\n//------------------------------------------------------------------------------\n\n// NOTE: this is a performance hack\n// The main result object uses a lot of \"unsigned integer or null\" values.\n// Using a negative integer is faster than actual null because it cuts down on\n// type coercion overhead.\nvar UINT_NULL = -999;\n\nvar INDENT_MODE = \"INDENT_MODE\",\n    PAREN_MODE = \"PAREN_MODE\";\n\nvar BACKSLASH = '\\\\',\n    BLANK_SPACE = ' ',\n    DOUBLE_SPACE = '  ',\n    DOUBLE_QUOTE = '\"',\n    NEWLINE = '\\n',\n    SEMICOLON = ';',\n    TAB = '\\t';\n\nvar LINE_ENDING_REGEX = /\\r?\\n/;\n\nvar MATCH_PAREN = {\n  \"{\": \"}\",\n  \"}\": \"{\",\n  \"[\": \"]\",\n  \"]\": \"[\",\n  \"(\": \")\",\n  \")\": \"(\"\n};\n\n// toggle this to check the asserts during development\nvar RUN_ASSERTS = false;\n\nfunction isBoolean(x) {\n  return typeof x === 'boolean';\n}\n\nfunction isArray(x) {\n  return Array.isArray(x);\n}\n\nfunction isInteger(x) {\n  return typeof x === 'number' &&\n         isFinite(x) &&\n         Math.floor(x) === x;\n}\n\n//------------------------------------------------------------------------------\n// Options Structure\n//------------------------------------------------------------------------------\n\nfunction transformChange(change) {\n  if (!change) {\n    return undefined;\n  }\n\n  var newLines = change.newText.split(LINE_ENDING_REGEX);\n  var oldLines = change.oldText.split(LINE_ENDING_REGEX);\n\n  // single line case:\n  //     (defn foo| [])\n  //              ^ newEndX, newEndLineNo\n  //           +++\n\n  // multi line case:\n  //     (defn foo\n  //           ++++\n  //        \"docstring.\"\n  //     ++++++++++++++++\n  //       |[])\n  //     ++^ newEndX, newEndLineNo\n\n  var lastOldLineLen = oldLines[oldLines.length-1].length;\n  var lastNewLineLen = newLines[newLines.length-1].length;\n\n  var oldEndX = (oldLines.length === 1 ? change.x : 0) + lastOldLineLen;\n  var newEndX = (newLines.length === 1 ? change.x : 0) + lastNewLineLen;\n  var newEndLineNo = change.lineNo + (newLines.length-1);\n\n  return {\n    x: change.x,\n    lineNo: change.lineNo,\n    oldText: change.oldText,\n    newText: change.newText,\n\n    oldEndX: oldEndX,\n    newEndX: newEndX,\n    newEndLineNo: newEndLineNo,\n\n    lookupLineNo: newEndLineNo,\n    lookupX: newEndX\n  };\n}\n\nfunction transformChanges(changes) {\n  if (changes.length === 0) {\n    return null;\n  }\n  var lines = {};\n  var line, i, change;\n  for (i=0; i<changes.length; i++) {\n    change = transformChange(changes[i]);\n    line = lines[change.lookupLineNo];\n    if (!line) {\n      line = lines[change.lookupLineNo] = {};\n    }\n    line[change.lookupX] = change;\n  }\n  return lines;\n}\n\nfunction parseOptions(options) {\n  options = options || {};\n  return {\n    cursorX: options.cursorX,\n    cursorLine: options.cursorLine,\n    prevCursorX: options.prevCursorX,\n    prevCursorLine: options.prevCursorLine,\n    selectionStartLine: options.selectionStartLine,\n    changes: options.changes,\n    partialResult: options.partialResult,\n    forceBalance: options.forceBalance,\n    returnParens: options.returnParens\n  };\n}\n\n//------------------------------------------------------------------------------\n// Result Structure\n//------------------------------------------------------------------------------\n\n// This represents the running result. As we scan through each character\n// of a given text, we mutate this structure to update the state of our\n// system.\n\nfunction initialParenTrail() {\n  return {\n    lineNo: UINT_NULL,       // [integer] - line number of the last parsed paren trail\n    startX: UINT_NULL,       // [integer] - x position of first paren in this range\n    endX: UINT_NULL,         // [integer] - x position after the last paren in this range\n    openers: [],             // [array of stack elements] - corresponding open-paren for each close-paren in this range\n    clamped: {\n      startX: UINT_NULL,     // startX before paren trail was clamped\n      endX: UINT_NULL,       // endX before paren trail was clamped\n      openers: []            // openers that were cut out after paren trail was clamped\n    }\n  };\n}\n\nfunction getInitialResult(text, options, mode, smart) {\n\n  var result = {\n\n    mode: mode,                // [enum] - current processing mode (INDENT_MODE or PAREN_MODE)\n    smart: smart,              // [boolean] - smart mode attempts special user-friendly behavior\n\n    origText: text,            // [string] - original text\n    origCursorX: UINT_NULL,    // [integer] - original cursorX option\n    origCursorLine: UINT_NULL, // [integer] - original cursorLine option\n\n    inputLines:                // [string array] - input lines that we process line-by-line, char-by-char\n      text.split(LINE_ENDING_REGEX),\n    inputLineNo: -1,           // [integer] - the current input line number\n    inputX: -1,                // [integer] - the current input x position of the current character (ch)\n\n    lines: [],                 // [string array] - output lines (with corrected parens or indentation)\n    lineNo: -1,                // [integer] - output line number we are on\n    ch: \"\",                    // [string] - character we are processing (can be changed to indicate a replacement)\n    x: 0,                      // [integer] - output x position of the current character (ch)\n    indentX: UINT_NULL,        // [integer] - x position of the indentation point if present\n\n    parenStack: [],            // We track where we are in the Lisp tree by keeping a stack (array) of open-parens.\n                               // Stack elements are objects containing keys {ch, x, lineNo, indentDelta}\n                               // whose values are the same as those described here in this result structure.\n\n    tabStops: [],              // In Indent Mode, it is useful for editors to snap a line's indentation\n                               // to certain critical points.  Thus, we have a `tabStops` array of objects containing\n                               // keys {ch, x, lineNo, argX}, which is just the state of the `parenStack` at the cursor line.\n\n    parenTrail: initialParenTrail(), // the range of parens at the end of a line\n\n    parenTrails: [],           // [array of {lineNo, startX, endX}] - all non-empty parenTrails to be returned\n\n    returnParens: false,       // [boolean] - determines if we return `parens` described below\n    parens: [],                // [array of {lineNo, x, closer, children}] - paren tree if `returnParens` is true\n\n    cursorX: UINT_NULL,        // [integer] - x position of the cursor\n    cursorLine: UINT_NULL,     // [integer] - line number of the cursor\n    prevCursorX: UINT_NULL,    // [integer] - x position of the previous cursor\n    prevCursorLine: UINT_NULL, // [integer] - line number of the previous cursor\n\n    selectionStartLine: UINT_NULL, // [integer] - line number of the current selection starting point\n\n    changes: null,             // [object] - mapping change.key to a change object (please see `transformChange` for object structure)\n\n    isInCode: true,            // [boolean] - indicates if we are currently in \"code space\" (not string or comment)\n    isEscaping: false,         // [boolean] - indicates if the next character will be escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isEscaped: false,          // [boolean] - indicates if the current character is escaped (e.g. `\\c`).  This may be inside string, comment, or code.\n    isInStr: false,            // [boolean] - indicates if we are currently inside a string\n    isInComment: false,        // [boolean] - indicates if we are currently inside a comment\n    commentX: UINT_NULL,       // [integer] - x position of the start of comment on current line (if any)\n\n    quoteDanger: false,        // [boolean] - indicates if quotes are imbalanced inside of a comment (dangerous)\n    trackingIndent: false,     // [boolean] - are we looking for the indentation point of the current line?\n    skipChar: false,           // [boolean] - should we skip the processing of the current character?\n    success: false,            // [boolean] - was the input properly formatted enough to create a valid result?\n    partialResult: false,      // [boolean] - should we return a partial result when an error occurs?\n    forceBalance: false,       // [boolean] - should indent mode aggressively enforce paren balance?\n\n    maxIndent: UINT_NULL,      // [integer] - maximum allowed indentation of subsequent lines in Paren Mode\n    indentDelta: 0,            // [integer] - how far indentation was shifted by Paren Mode\n                               //  (preserves relative indentation of nested expressions)\n\n    trackingArgTabStop: null,  // [string] - enum to track how close we are to the first-arg tabStop in a list\n                               //  For example a tabStop occurs at `bar` below:\n                               //\n                               //         `   (foo    bar`\n                               //          00011112222000  <-- state after processing char (enums below)\n                               //\n                               //         0   null    => not searching\n                               //         1   'space' => searching for next space\n                               //         2   'arg'   => searching for arg\n                               //\n                               //    (We create the tabStop when the change from 2->0 happens.)\n                               //\n\n    error: {                   // if 'success' is false, return this error to the user\n      name: null,              // [string] - Parinfer's unique name for this error\n      message: null,           // [string] - error message to display\n      lineNo: null,            // [integer] - line number of error\n      x: null,                 // [integer] - start x position of error\n      extra: {\n        name: null,\n        lineNo: null,\n        x: null\n      }\n    },\n    errorPosCache: {}          // [object] - maps error name to a potential error position\n  };\n\n  // Make sure no new properties are added to the result, for type safety.\n  // (uncomment only when debugging, since it incurs a perf penalty)\n  // Object.preventExtensions(result);\n  // Object.preventExtensions(result.parenTrail);\n\n  // merge options if they are valid\n  if (options) {\n    if (isInteger(options.cursorX))            { result.cursorX            = options.cursorX;\n                                                 result.origCursorX        = options.cursorX; }\n    if (isInteger(options.cursorLine))         { result.cursorLine         = options.cursorLine;\n                                                 result.origCursorLine     = options.cursorLine; }\n    if (isInteger(options.prevCursorX))        { result.prevCursorX        = options.prevCursorX; }\n    if (isInteger(options.prevCursorLine))     { result.prevCursorLine     = options.prevCursorLine; }\n    if (isInteger(options.selectionStartLine)) { result.selectionStartLine = options.selectionStartLine; }\n    if (isArray(options.changes))              { result.changes            = transformChanges(options.changes); }\n    if (isBoolean(options.partialResult))      { result.partialResult      = options.partialResult; }\n    if (isBoolean(options.forceBalance))       { result.forceBalance       = options.forceBalance; }\n    if (isBoolean(options.returnParens))       { result.returnParens       = options.returnParens; }\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Possible Errors\n//------------------------------------------------------------------------------\n\n// `result.error.name` is set to any of these\nvar ERROR_QUOTE_DANGER = \"quote-danger\";\nvar ERROR_EOL_BACKSLASH = \"eol-backslash\";\nvar ERROR_UNCLOSED_QUOTE = \"unclosed-quote\";\nvar ERROR_UNCLOSED_PAREN = \"unclosed-paren\";\nvar ERROR_UNMATCHED_CLOSE_PAREN = \"unmatched-close-paren\";\nvar ERROR_UNMATCHED_OPEN_PAREN = \"unmatched-open-paren\";\nvar ERROR_LEADING_CLOSE_PAREN = \"leading-close-paren\";\nvar ERROR_UNHANDLED = \"unhandled\";\n\nvar errorMessages = {};\nerrorMessages[ERROR_QUOTE_DANGER] = \"Quotes must balanced inside comment blocks.\";\nerrorMessages[ERROR_EOL_BACKSLASH] = \"Line cannot end in a hanging backslash.\";\nerrorMessages[ERROR_UNCLOSED_QUOTE] = \"String is missing a closing quote.\";\nerrorMessages[ERROR_UNCLOSED_PAREN] = \"Unclosed open-paren.\";\nerrorMessages[ERROR_UNMATCHED_CLOSE_PAREN] = \"Unmatched close-paren.\";\nerrorMessages[ERROR_UNMATCHED_OPEN_PAREN] = \"Unmatched open-paren.\";\nerrorMessages[ERROR_LEADING_CLOSE_PAREN] = \"Line cannot lead with a close-paren.\";\nerrorMessages[ERROR_UNHANDLED] = \"Unhandled error.\";\n\nfunction cacheErrorPos(result, errorName) {\n  var e = {\n    lineNo: result.lineNo,\n    x: result.x,\n    inputLineNo: result.inputLineNo,\n    inputX: result.inputX\n  };\n  result.errorPosCache[errorName] = e;\n  return e;\n}\n\nfunction error(result, name) {\n  var cache = result.errorPosCache[name];\n\n  var keyLineNo = result.partialResult ? 'lineNo' : 'inputLineNo';\n  var keyX = result.partialResult ? 'x' : 'inputX';\n\n  var e = {\n    parinferError: true,\n    name: name,\n    message: errorMessages[name],\n    lineNo: cache ? cache[keyLineNo] : result[keyLineNo],\n    x: cache ? cache[keyX] : result[keyX]\n  };\n  var opener = peek(result.parenStack, 0);\n\n  if (name === ERROR_UNMATCHED_CLOSE_PAREN) {\n    // extra error info for locating the open-paren that it should've matched\n    cache = result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n    if (cache || opener) {\n      e.extra = {\n        name: ERROR_UNMATCHED_OPEN_PAREN,\n        lineNo: cache ? cache[keyLineNo] : opener[keyLineNo],\n        x: cache ? cache[keyX] : opener[keyX]\n      };\n    }\n  }\n  else if (name === ERROR_UNCLOSED_PAREN) {\n    e.lineNo = opener[keyLineNo];\n    e.x = opener[keyX];\n  }\n  return e;\n}\n\n//------------------------------------------------------------------------------\n// String Operations\n//------------------------------------------------------------------------------\n\nfunction replaceWithinString(orig, start, end, replace) {\n  return (\n    orig.substring(0, start) +\n    replace +\n    orig.substring(end)\n  );\n}\n\nif (RUN_ASSERTS) {\n  console.assert(replaceWithinString('aaa', 0, 2, '') === 'a');\n  console.assert(replaceWithinString('aaa', 0, 1, 'b') === 'baa');\n  console.assert(replaceWithinString('aaa', 0, 2, 'b') === 'ba');\n}\n\nfunction repeatString(text, n) {\n  var i;\n  var result = \"\";\n  for (i = 0; i < n; i++) {\n    result += text;\n  }\n  return result;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(repeatString('a', 2) === 'aa');\n  console.assert(repeatString('aa', 3) === 'aaaaaa');\n  console.assert(repeatString('aa', 0) === '');\n  console.assert(repeatString('', 0) === '');\n  console.assert(repeatString('', 5) === '');\n}\n\nfunction getLineEnding(text) {\n  // NOTE: We assume that if the CR char \"\\r\" is used anywhere,\n  //       then we should use CRLF line-endings after every line.\n  var i = text.search(\"\\r\");\n  if (i !== -1) {\n    return \"\\r\\n\";\n  }\n  return \"\\n\";\n}\n\n//------------------------------------------------------------------------------\n// Line operations\n//------------------------------------------------------------------------------\n\nfunction isCursorAffected(result, start, end) {\n  if (result.cursorX === start &&\n      result.cursorX === end) {\n    return result.cursorX === 0;\n  }\n  return result.cursorX >= end;\n}\n\nfunction shiftCursorOnEdit(result, lineNo, start, end, replace) {\n  var oldLength = end - start;\n  var newLength = replace.length;\n  var dx = newLength - oldLength;\n\n  if (dx !== 0 &&\n      result.cursorLine === lineNo &&\n      result.cursorX !== UINT_NULL &&\n      isCursorAffected(result, start, end)) {\n    result.cursorX += dx;\n  }\n}\n\nfunction replaceWithinLine(result, lineNo, start, end, replace) {\n  var line = result.lines[lineNo];\n  var newLine = replaceWithinString(line, start, end, replace);\n  result.lines[lineNo] = newLine;\n\n  shiftCursorOnEdit(result, lineNo, start, end, replace);\n}\n\nfunction insertWithinLine(result, lineNo, idx, insert) {\n  replaceWithinLine(result, lineNo, idx, idx, insert);\n}\n\nfunction initLine(result) {\n  result.x = 0;\n  result.lineNo++;\n\n  // reset line-specific state\n  result.indentX = UINT_NULL;\n  result.commentX = UINT_NULL;\n  result.indentDelta = 0;\n  delete result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  delete result.errorPosCache[ERROR_UNMATCHED_OPEN_PAREN];\n  delete result.errorPosCache[ERROR_LEADING_CLOSE_PAREN];\n\n  result.trackingArgTabStop = null;\n  result.trackingIndent = !result.isInStr;\n}\n\n// if the current character has changed, commit its change to the current line.\nfunction commitChar(result, origCh) {\n  var ch = result.ch;\n  if (origCh !== ch) {\n    replaceWithinLine(result, result.lineNo, result.x, result.x + origCh.length, ch);\n    result.indentDelta -= (origCh.length - ch.length);\n  }\n  result.x += ch.length;\n}\n\n//------------------------------------------------------------------------------\n// Misc Utils\n//------------------------------------------------------------------------------\n\nfunction clamp(val, minN, maxN) {\n  if (minN !== UINT_NULL) {\n    val = Math.max(minN, val);\n  }\n  if (maxN !== UINT_NULL) {\n    val = Math.min(maxN, val);\n  }\n  return val;\n}\n\nif (RUN_ASSERTS) {\n  console.assert(clamp(1, 3, 5) === 3);\n  console.assert(clamp(9, 3, 5) === 5);\n  console.assert(clamp(1, 3, UINT_NULL) === 3);\n  console.assert(clamp(5, 3, UINT_NULL) === 5);\n  console.assert(clamp(1, UINT_NULL, 5) === 1);\n  console.assert(clamp(9, UINT_NULL, 5) === 5);\n  console.assert(clamp(1, UINT_NULL, UINT_NULL) === 1);\n}\n\nfunction peek(arr, idxFromBack) {\n  var maxIdx = arr.length - 1;\n  if (idxFromBack > maxIdx) {\n    return null;\n  }\n  return arr[maxIdx - idxFromBack];\n}\n\nif (RUN_ASSERTS) {\n  console.assert(peek(['a'], 0) === 'a');\n  console.assert(peek(['a'], 1) === null);\n  console.assert(peek(['a', 'b', 'c'], 0) === 'c');\n  console.assert(peek(['a', 'b', 'c'], 1) === 'b');\n  console.assert(peek(['a', 'b', 'c'], 5) === null);\n  console.assert(peek([], 0) === null);\n  console.assert(peek([], 1) === null);\n}\n\n//------------------------------------------------------------------------------\n// Questions about characters\n//------------------------------------------------------------------------------\n\nfunction isOpenParen(ch) {\n  return ch === \"{\" || ch === \"(\" || ch === \"[\";\n}\n\nfunction isCloseParen(ch) {\n  return ch === \"}\" || ch === \")\" || ch === \"]\";\n}\n\nfunction isValidCloseParen(parenStack, ch) {\n  if (parenStack.length === 0) {\n    return false;\n  }\n  return peek(parenStack, 0).ch === MATCH_PAREN[ch];\n}\n\nfunction isWhitespace(result) {\n  var ch = result.ch;\n  return !result.isEscaped && (ch === BLANK_SPACE || ch === DOUBLE_SPACE);\n}\n\n// can this be the last code character of a list?\nfunction isClosable(result) {\n  var ch = result.ch;\n  var closer = (isCloseParen(ch) && !result.isEscaped);\n  return result.isInCode && !isWhitespace(result) && ch !== \"\" && !closer;\n}\n\n//------------------------------------------------------------------------------\n// Advanced operations on characters\n//------------------------------------------------------------------------------\n\nfunction checkCursorHolding(result) {\n  var opener = peek(result.parenStack, 0);\n  var parent = peek(result.parenStack, 1);\n  var holdMinX = parent ? parent.x+1 : 0;\n  var holdMaxX = opener.x;\n\n  var holding = (\n    result.cursorLine === opener.lineNo &&\n    holdMinX <= result.cursorX && result.cursorX <= holdMaxX\n  );\n  var shouldCheckPrev = !result.changes && result.prevCursorLine !== UINT_NULL;\n  if (shouldCheckPrev) {\n    var prevHolding = (\n      result.prevCursorLine === opener.lineNo &&\n      holdMinX <= result.prevCursorX && result.prevCursorX <= holdMaxX\n    );\n    if (prevHolding && !holding) {\n      throw {releaseCursorHold: true};\n    }\n  }\n  return holding;\n}\n\nfunction trackArgTabStop(result, state) {\n  if (state === 'space') {\n    if (result.isInCode && isWhitespace(result)) {\n      result.trackingArgTabStop = 'arg';\n    }\n  }\n  else if (state === 'arg') {\n    if (!isWhitespace(result)) {\n        var opener = peek(result.parenStack, 0);\n        opener.argX = result.x;\n        result.trackingArgTabStop = null;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Literal character events\n//------------------------------------------------------------------------------\n\nfunction onOpenParen(result) {\n  if (result.isInCode) {\n    var opener = {\n      inputLineNo: result.inputLineNo,\n      inputX: result.inputX,\n\n      lineNo: result.lineNo,\n      x: result.x,\n      ch: result.ch,\n      indentDelta: result.indentDelta,\n      maxChildIndent: UINT_NULL\n    };\n\n    if (result.returnParens) {\n      opener.children = [];\n      opener.closer = {\n        lineNo: UINT_NULL,\n        x: UINT_NULL,\n        ch: ''\n      };\n      var parent = peek(result.parenStack, 0);\n      parent = parent ? parent.children : result.parens;\n      parent.push(opener);\n    }\n\n    result.parenStack.push(opener);\n    result.trackingArgTabStop = 'space';\n  }\n}\n\nfunction setCloser(opener, lineNo, x, ch) {\n  opener.closer.lineNo = lineNo;\n  opener.closer.x = x;\n  opener.closer.ch = ch;\n}\n\nfunction onMatchedCloseParen(result) {\n  var opener = peek(result.parenStack, 0);\n  if (result.returnParens) {\n    setCloser(opener, result.lineNo, result.x, result.ch);\n  }\n\n  result.parenTrail.endX = result.x + 1;\n  result.parenTrail.openers.push(opener);\n\n  if (result.mode === INDENT_MODE && result.smart && checkCursorHolding(result)) {\n    var origStartX = result.parenTrail.startX;\n    var origEndX = result.parenTrail.endX;\n    var origOpeners = result.parenTrail.openers;\n    resetParenTrail(result, result.lineNo, result.x+1);\n    result.parenTrail.clamped.startX = origStartX;\n    result.parenTrail.clamped.endX = origEndX;\n    result.parenTrail.clamped.openers = origOpeners;\n  }\n  result.parenStack.pop();\n  result.trackingArgTabStop = null;\n}\n\nfunction onUnmatchedCloseParen(result) {\n  if (result.mode === PAREN_MODE) {\n    var trail = result.parenTrail;\n    var inLeadingParenTrail = trail.lineNo === result.lineNo && trail.startX === result.indentX;\n    var canRemove = result.smart && inLeadingParenTrail;\n    if (!canRemove) {\n      throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    }\n  }\n  else if (result.mode === INDENT_MODE && !result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN]) {\n    cacheErrorPos(result, ERROR_UNMATCHED_CLOSE_PAREN);\n    var opener = peek(result.parenStack, 0);\n    if (opener) {\n      var e = cacheErrorPos(result, ERROR_UNMATCHED_OPEN_PAREN);\n      e.inputLineNo = opener.inputLineNo;\n      e.inputX = opener.inputX;\n    }\n  }\n  result.ch = \"\";\n}\n\nfunction onCloseParen(result) {\n  if (result.isInCode) {\n    if (isValidCloseParen(result.parenStack, result.ch)) {\n      onMatchedCloseParen(result);\n    }\n    else {\n      onUnmatchedCloseParen(result);\n    }\n  }\n}\n\nfunction onTab(result) {\n  if (result.isInCode) {\n    result.ch = DOUBLE_SPACE;\n  }\n}\n\nfunction onSemicolon(result) {\n  if (result.isInCode) {\n    result.isInComment = true;\n    result.commentX = result.x;\n    result.trackingArgTabStop = null;\n  }\n}\n\nfunction onNewline(result) {\n  result.isInComment = false;\n  result.ch = \"\";\n}\n\nfunction onQuote(result) {\n  if (result.isInStr) {\n    result.isInStr = false;\n  }\n  else if (result.isInComment) {\n    result.quoteDanger = !result.quoteDanger;\n    if (result.quoteDanger) {\n      cacheErrorPos(result, ERROR_QUOTE_DANGER);\n    }\n  }\n  else {\n    result.isInStr = true;\n    cacheErrorPos(result, ERROR_UNCLOSED_QUOTE);\n  }\n}\n\nfunction onBackslash(result) {\n  result.isEscaping = true;\n}\n\nfunction afterBackslash(result) {\n  result.isEscaping = false;\n  result.isEscaped = true;\n\n  if (result.ch === NEWLINE) {\n    if (result.isInCode) {\n      throw error(result, ERROR_EOL_BACKSLASH);\n    }\n    onNewline(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Character dispatch\n//------------------------------------------------------------------------------\n\nfunction onChar(result) {\n  var ch = result.ch;\n  result.isEscaped = false;\n\n  if (result.isEscaping)        { afterBackslash(result); }\n  else if (isOpenParen(ch))     { onOpenParen(result); }\n  else if (isCloseParen(ch))    { onCloseParen(result); }\n  else if (ch === DOUBLE_QUOTE) { onQuote(result); }\n  else if (ch === SEMICOLON)    { onSemicolon(result); }\n  else if (ch === BACKSLASH)    { onBackslash(result); }\n  else if (ch === TAB)          { onTab(result); }\n  else if (ch === NEWLINE)      { onNewline(result); }\n\n  ch = result.ch;\n\n  result.isInCode = !result.isInComment && !result.isInStr;\n\n  if (isClosable(result)) {\n    resetParenTrail(result, result.lineNo, result.x+ch.length);\n  }\n\n  var state = result.trackingArgTabStop;\n  if (state) {\n     trackArgTabStop(result, state);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Cursor functions\n//------------------------------------------------------------------------------\n\nfunction isCursorLeftOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX <= x // inclusive since (cursorX = x) implies (x-1 < cursor < x)\n  );\n}\n\nfunction isCursorRightOf(cursorX, cursorLine, x, lineNo) {\n  return (\n    cursorLine === lineNo &&\n    x !== UINT_NULL &&\n    cursorX !== UINT_NULL &&\n    cursorX > x\n  );\n}\n\nfunction isCursorInComment(result, cursorX, cursorLine) {\n  return isCursorRightOf(cursorX, cursorLine, result.commentX, result.lineNo);\n}\n\nfunction handleChangeDelta(result) {\n  if (result.changes && (result.smart || result.mode === PAREN_MODE)) {\n    var line = result.changes[result.inputLineNo];\n    if (line) {\n      var change = line[result.inputX];\n      if (change) {\n        result.indentDelta += (change.newEndX - change.oldEndX);\n      }\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// Paren Trail functions\n//------------------------------------------------------------------------------\n\nfunction resetParenTrail(result, lineNo, x) {\n  result.parenTrail.lineNo = lineNo;\n  result.parenTrail.startX = x;\n  result.parenTrail.endX = x;\n  result.parenTrail.openers = [];\n  result.parenTrail.clamped.startX = UINT_NULL;\n  result.parenTrail.clamped.endX = UINT_NULL;\n  result.parenTrail.clamped.openers = [];\n}\n\nfunction isCursorClampingParenTrail(result, cursorX, cursorLine) {\n  return (\n    isCursorRightOf(cursorX, cursorLine, result.parenTrail.startX, result.lineNo) &&\n    !isCursorInComment(result, cursorX, cursorLine)\n  );\n}\n\n// INDENT MODE: allow the cursor to clamp the paren trail\nfunction clampParenTrailToCursor(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  var clamping = isCursorClampingParenTrail(result, result.cursorX, result.cursorLine);\n\n  if (clamping) {\n    var newStartX = Math.max(startX, result.cursorX);\n    var newEndX = Math.max(endX, result.cursorX);\n\n    var line = result.lines[result.lineNo];\n    var removeCount = 0;\n    var i;\n    for (i = startX; i < newStartX; i++) {\n      if (isCloseParen(line[i])) {\n        removeCount++;\n      }\n    }\n\n    var openers = result.parenTrail.openers;\n\n    result.parenTrail.openers = openers.slice(removeCount);\n    result.parenTrail.startX = newStartX;\n    result.parenTrail.endX = newEndX;\n\n    result.parenTrail.clamped.openers = openers.slice(0, removeCount);\n    result.parenTrail.clamped.startX = startX;\n    result.parenTrail.clamped.endX = endX;\n  }\n}\n\n// INDENT MODE: pops the paren trail from the stack\nfunction popParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX) {\n    return;\n  }\n\n  var openers = result.parenTrail.openers;\n  while (openers.length !== 0) {\n    result.parenStack.push(openers.pop());\n  }\n}\n\n// Determine which open-paren (if any) on the parenStack should be considered\n// the direct parent of the current line (given its indentation point).\n// This allows Smart Mode to simulate Paren Mode's structure-preserving\n// behavior by adding its `opener.indentDelta` to the current line's indentation.\n// (care must be taken to prevent redundant indentation correction, detailed below)\nfunction getParentOpenerIndex(result, indentX) {\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    var opener = peek(result.parenStack, i);\n\n    var currOutside = (opener.x < indentX);\n\n    var prevIndentX = indentX - result.indentDelta;\n    var prevOutside = (opener.x - opener.indentDelta < prevIndentX);\n\n    var isParent = false;\n\n    if (prevOutside && currOutside) {\n      isParent = true;\n    }\n    else if (!prevOutside && !currOutside) {\n      isParent = false;\n    }\n    else if (prevOutside && !currOutside) {\n      // POSSIBLE FRAGMENTATION\n      // (foo    --\\\n      //            +--- FRAGMENT `(foo bar)` => `(foo) bar`\n      // bar)    --/\n\n      // 1. PREVENT FRAGMENTATION\n      // ```in\n      //   (foo\n      // ++\n      //   bar\n      // ```\n      // ```out\n      //   (foo\n      //     bar\n      // ```\n      if (result.indentDelta === 0) {\n        isParent = true;\n      }\n\n      // 2. ALLOW FRAGMENTATION\n      // ```in\n      // (foo\n      //   bar\n      // --\n      // ```\n      // ```out\n      // (foo)\n      // bar\n      // ```\n      else if (opener.indentDelta === 0) {\n        isParent = false;\n      }\n\n      else {\n        // TODO: identify legitimate cases where both are nonzero\n\n        // allow the fragmentation by default\n        isParent = false;\n\n        // TODO: should we throw to exit instead?  either of:\n        // 1. give up, just `throw error(...)`\n        // 2. fallback to paren mode to preserve structure\n      }\n    }\n    else if (!prevOutside && currOutside) {\n      // POSSIBLE ADOPTION\n      // (foo)   --\\\n      //            +--- ADOPT `(foo) bar` => `(foo bar)`\n      //   bar   --/\n\n      var nextOpener = peek(result.parenStack, i+1);\n\n      // 1. DISALLOW ADOPTION\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar)\n      //   baz)\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // --\n      //     (bar)\n      // -\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //  (bar)\n      //  baz)\n      // ```\n      if (nextOpener && nextOpener.indentDelta <= opener.indentDelta) {\n        // we can only disallow adoption if nextOpener.indentDelta will actually\n        // prevent the indentX from being in the opener's threshold.\n        if (indentX + nextOpener.indentDelta > opener.x) {\n          isParent = true;\n        }\n        else {\n          isParent = false;\n        }\n      }\n\n      // 2. ALLOW ADOPTION\n      // ```in\n      // (foo\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      // (foo\n      //   (bar\n      //     baz))\n      // ```\n      // OR\n      // ```in\n      //   (foo\n      // -\n      //     (bar)\n      // --\n      //     baz)\n      // ```\n      // ```out\n      //  (foo\n      //   (bar)\n      //    baz)\n      // ```\n      else if (nextOpener && nextOpener.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      // 3. ALLOW ADOPTION\n      // ```in\n      //   (foo)\n      // --\n      //   bar\n      // ```\n      // ```out\n      // (foo\n      //   bar)\n      // ```\n      // OR\n      // ```in\n      // (foo)\n      //   bar\n      // ++\n      // ```\n      // ```out\n      // (foo\n      //   bar\n      // ```\n      // OR\n      // ```in\n      //  (foo)\n      // +\n      //   bar\n      // ++\n      // ```\n      // ```out\n      //  (foo\n      //   bar)\n      // ```\n      else if (result.indentDelta > opener.indentDelta) {\n        isParent = true;\n      }\n\n      if (isParent) { // if new parent\n        // Clear `indentDelta` since it is reserved for previous child lines only.\n        opener.indentDelta = 0;\n      }\n    }\n\n    if (isParent) {\n      break;\n    }\n  }\n  return i;\n}\n\n// INDENT MODE: correct paren trail from indentation\nfunction correctParenTrail(result, indentX) {\n  var parens = \"\";\n\n  var index = getParentOpenerIndex(result, indentX);\n  var i;\n  for (i=0; i<index; i++) {\n    var opener = result.parenStack.pop();\n    result.parenTrail.openers.push(opener);\n    var closeCh = MATCH_PAREN[opener.ch];\n    parens += closeCh;\n\n    if (result.returnParens) {\n      setCloser(opener, result.parenTrail.lineNo, result.parenTrail.startX+i, closeCh);\n    }\n  }\n\n  if (result.parenTrail.lineNo !== UINT_NULL) {\n    replaceWithinLine(result, result.parenTrail.lineNo, result.parenTrail.startX, result.parenTrail.endX, parens);\n    result.parenTrail.endX = result.parenTrail.startX + parens.length;\n    rememberParenTrail(result);\n  }\n}\n\n// PAREN MODE: remove spaces from the paren trail\nfunction cleanParenTrail(result) {\n  var startX = result.parenTrail.startX;\n  var endX = result.parenTrail.endX;\n\n  if (startX === endX ||\n      result.lineNo !== result.parenTrail.lineNo) {\n    return;\n  }\n\n  var line = result.lines[result.lineNo];\n  var newTrail = \"\";\n  var spaceCount = 0;\n  var i;\n  for (i = startX; i < endX; i++) {\n    if (isCloseParen(line[i])) {\n      newTrail += line[i];\n    }\n    else {\n      spaceCount++;\n    }\n  }\n\n  if (spaceCount > 0) {\n    replaceWithinLine(result, result.lineNo, startX, endX, newTrail);\n    result.parenTrail.endX -= spaceCount;\n  }\n}\n\n// PAREN MODE: append a valid close-paren to the end of the paren trail\nfunction appendParenTrail(result) {\n  var opener = result.parenStack.pop();\n  var closeCh = MATCH_PAREN[opener.ch];\n  if (result.returnParens) {\n    setCloser(opener, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n  }\n\n  setMaxIndent(result, opener);\n  insertWithinLine(result, result.parenTrail.lineNo, result.parenTrail.endX, closeCh);\n\n  result.parenTrail.endX++;\n  result.parenTrail.openers.push(opener);\n  updateRememberedParenTrail(result);\n}\n\nfunction invalidateParenTrail(result) {\n  result.parenTrail = initialParenTrail();\n}\n\nfunction checkUnmatchedOutsideParenTrail(result) {\n  var cache = result.errorPosCache[ERROR_UNMATCHED_CLOSE_PAREN];\n  if (cache && cache.x < result.parenTrail.startX) {\n    throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n  }\n}\n\nfunction setMaxIndent(result, opener) {\n  if (opener) {\n    var parent = peek(result.parenStack, 0);\n    if (parent) {\n      parent.maxChildIndent = opener.x;\n    }\n    else {\n      result.maxIndent = opener.x;\n    }\n  }\n}\n\nfunction rememberParenTrail(result) {\n  var trail = result.parenTrail;\n  var openers = trail.clamped.openers.concat(trail.openers);\n  if (openers.length > 0) {\n    var isClamped = trail.clamped.startX !== UINT_NULL;\n    var allClamped = trail.openers.length === 0;\n    var shortTrail = {\n      lineNo: trail.lineNo,\n      startX: isClamped ? trail.clamped.startX : trail.startX,\n      endX: allClamped ? trail.clamped.endX : trail.endX\n    };\n    result.parenTrails.push(shortTrail);\n\n    if (result.returnParens) {\n      var i;\n      for (i=0; i<openers.length; i++) {\n        openers[i].closer.trail = shortTrail;\n      }\n    }\n  }\n}\n\nfunction updateRememberedParenTrail(result) {\n  var trail = result.parenTrails[result.parenTrails.length-1];\n  if (!trail || trail.lineNo !== result.parenTrail.lineNo) {\n    rememberParenTrail(result);\n  }\n  else {\n    trail.endX = result.parenTrail.endX;\n    if (result.returnParens) {\n      var opener = result.parenTrail.openers[result.parenTrail.openers.length-1];\n      opener.closer.trail = trail;\n    }\n  }\n}\n\nfunction finishNewParenTrail(result) {\n  if (result.isInStr) {\n    invalidateParenTrail(result);\n  }\n  else if (result.mode === INDENT_MODE) {\n    clampParenTrailToCursor(result);\n    popParenTrail(result);\n  }\n  else if (result.mode === PAREN_MODE) {\n    setMaxIndent(result, peek(result.parenTrail.openers, 0));\n    if (result.lineNo !== result.cursorLine) {\n      cleanParenTrail(result);\n    }\n    rememberParenTrail(result);\n  }\n}\n\n//------------------------------------------------------------------------------\n// Indentation functions\n//------------------------------------------------------------------------------\n\nfunction addIndent(result, delta) {\n  var origIndent = result.x;\n  var newIndent = origIndent + delta;\n  var indentStr = repeatString(BLANK_SPACE, newIndent);\n  replaceWithinLine(result, result.lineNo, 0, origIndent, indentStr);\n  result.x = newIndent;\n  result.indentX = newIndent;\n  result.indentDelta += delta;\n}\n\nfunction shouldAddOpenerIndent(result, opener) {\n  // Don't add opener.indentDelta if the user already added it.\n  // (happens when multiple lines are indented together)\n  return (opener.indentDelta !== result.indentDelta);\n}\n\nfunction correctIndent(result) {\n  var origIndent = result.x;\n  var newIndent = origIndent;\n  var minIndent = 0;\n  var maxIndent = result.maxIndent;\n\n  var opener = peek(result.parenStack, 0);\n  if (opener) {\n    minIndent = opener.x + 1;\n    maxIndent = opener.maxChildIndent;\n    if (shouldAddOpenerIndent(result, opener)) {\n      newIndent += opener.indentDelta;\n    }\n  }\n\n  newIndent = clamp(newIndent, minIndent, maxIndent);\n\n  if (newIndent !== origIndent) {\n    addIndent(result, newIndent - origIndent);\n  }\n}\n\nfunction onIndent(result) {\n  result.indentX = result.x;\n  result.trackingIndent = false;\n\n  if (result.quoteDanger) {\n    throw error(result, ERROR_QUOTE_DANGER);\n  }\n\n  if (result.mode === INDENT_MODE) {\n\n    correctParenTrail(result, result.x);\n\n    var opener = peek(result.parenStack, 0);\n    if (opener && shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n  }\n  else if (result.mode === PAREN_MODE) {\n    correctIndent(result);\n  }\n}\n\nfunction checkLeadingCloseParen(result) {\n  if (result.errorPosCache[ERROR_LEADING_CLOSE_PAREN] &&\n      result.parenTrail.lineNo === result.lineNo) {\n    throw error(result, ERROR_LEADING_CLOSE_PAREN);\n  }\n}\n\nfunction onLeadingCloseParen(result) {\n  if (result.mode === INDENT_MODE) {\n    if (!result.forceBalance) {\n      if (result.smart) {\n        throw {leadingCloseParen: true};\n      }\n      if (!result.errorPosCache[ERROR_LEADING_CLOSE_PAREN]) {\n        cacheErrorPos(result, ERROR_LEADING_CLOSE_PAREN);\n      }\n    }\n    result.skipChar = true;\n  }\n  if (result.mode === PAREN_MODE) {\n    if (!isValidCloseParen(result.parenStack, result.ch)) {\n      if (result.smart) {\n        result.skipChar = true;\n      }\n      else {\n        throw error(result, ERROR_UNMATCHED_CLOSE_PAREN);\n      }\n    }\n    else if (isCursorLeftOf(result.cursorX, result.cursorLine, result.x, result.lineNo)) {\n      resetParenTrail(result, result.lineNo, result.x);\n      onIndent(result);\n    }\n    else {\n      appendParenTrail(result);\n      result.skipChar = true;\n    }\n  }\n}\n\nfunction onCommentLine(result) {\n  var parenTrailLength = result.parenTrail.openers.length;\n\n  // restore the openers matching the previous paren trail\n  var j;\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.push(peek(result.parenTrail.openers, j));\n    }\n  }\n\n  var i = getParentOpenerIndex(result, result.x);\n  var opener = peek(result.parenStack, i);\n  if (opener) {\n    // shift the comment line based on the parent open paren\n    if (shouldAddOpenerIndent(result, opener)) {\n      addIndent(result, opener.indentDelta);\n    }\n    // TODO: store some information here if we need to place close-parens after comment lines\n  }\n\n  // repop the openers matching the previous paren trail\n  if (result.mode === PAREN_MODE) {\n    for (j=0; j<parenTrailLength; j++) {\n      result.parenStack.pop();\n    }\n  }\n}\n\nfunction checkIndent(result) {\n  if (isCloseParen(result.ch)) {\n    onLeadingCloseParen(result);\n  }\n  else if (result.ch === SEMICOLON) {\n    // comments don't count as indentation points\n    onCommentLine(result);\n    result.trackingIndent = false;\n  }\n  else if (result.ch !== NEWLINE &&\n           result.ch !== BLANK_SPACE &&\n           result.ch !== TAB) {\n    onIndent(result);\n  }\n}\n\nfunction makeTabStop(result, opener) {\n  var tabStop = {\n    ch: opener.ch,\n    x: opener.x,\n    lineNo: opener.lineNo\n  };\n  if (opener.argX != null) {\n    tabStop.argX = opener.argX;\n  }\n  return tabStop;\n}\n\nfunction getTabStopLine(result) {\n  return result.selectionStartLine !== UINT_NULL ? result.selectionStartLine : result.cursorLine;\n}\n\nfunction setTabStops(result) {\n  if (getTabStopLine(result) !== result.lineNo) {\n    return;\n  }\n\n  var i;\n  for (i=0; i<result.parenStack.length; i++) {\n    result.tabStops.push(makeTabStop(result, result.parenStack[i]));\n  }\n\n  if (result.mode === PAREN_MODE) {\n    for (i=result.parenTrail.openers.length-1; i>=0; i--) {\n      result.tabStops.push(makeTabStop(result, result.parenTrail.openers[i]));\n    }\n  }\n\n  // remove argX if it falls to the right of the next stop\n  for (i=1; i<result.tabStops.length; i++) {\n    var x = result.tabStops[i].x;\n    var prevArgX = result.tabStops[i-1].argX;\n    if (prevArgX != null && prevArgX >= x) {\n      delete result.tabStops[i-1].argX;\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n// High-level processing functions\n//------------------------------------------------------------------------------\n\nfunction processChar(result, ch) {\n  var origCh = ch;\n\n  result.ch = ch;\n  result.skipChar = false;\n\n  handleChangeDelta(result);\n\n  if (result.trackingIndent) {\n    checkIndent(result);\n  }\n\n  if (result.skipChar) {\n    result.ch = \"\";\n  }\n  else {\n    onChar(result);\n  }\n\n  commitChar(result, origCh);\n}\n\nfunction processLine(result, lineNo) {\n  initLine(result);\n  result.lines.push(result.inputLines[lineNo]);\n\n  setTabStops(result);\n\n  var x;\n  for (x = 0; x < result.inputLines[lineNo].length; x++) {\n    result.inputX = x;\n    processChar(result, result.inputLines[lineNo][x]);\n  }\n  processChar(result, NEWLINE);\n\n  if (!result.forceBalance) {\n    checkUnmatchedOutsideParenTrail(result);\n    checkLeadingCloseParen(result);\n  }\n\n  if (result.lineNo === result.parenTrail.lineNo) {\n    finishNewParenTrail(result);\n  }\n}\n\nfunction finalizeResult(result) {\n  if (result.quoteDanger) { throw error(result, ERROR_QUOTE_DANGER); }\n  if (result.isInStr)     { throw error(result, ERROR_UNCLOSED_QUOTE); }\n\n  if (result.parenStack.length !== 0) {\n    if (result.mode === PAREN_MODE) {\n      throw error(result, ERROR_UNCLOSED_PAREN);\n    }\n  }\n  if (result.mode === INDENT_MODE) {\n    initLine(result);\n    onIndent(result);\n  }\n  result.success = true;\n}\n\nfunction processError(result, e) {\n  result.success = false;\n  if (e.parinferError) {\n    delete e.parinferError;\n    result.error = e;\n  }\n  else {\n    result.error.name = ERROR_UNHANDLED;\n    result.error.message = e.stack;\n    throw e;\n  }\n}\n\nfunction processText(text, options, mode, smart) {\n  var result = getInitialResult(text, options, mode, smart);\n\n  try {\n    var i;\n    for (i = 0; i < result.inputLines.length; i++) {\n      result.inputLineNo = i;\n      processLine(result, i);\n    }\n    finalizeResult(result);\n  }\n  catch (e) {\n    if (e.leadingCloseParen || e.releaseCursorHold) {\n      return processText(text, options, PAREN_MODE, smart);\n    }\n    processError(result, e);\n  }\n\n  return result;\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nfunction publicResult(result) {\n  var lineEnding = getLineEnding(result.origText);\n  var final;\n  if (result.success) {\n    final = {\n      text: result.lines.join(lineEnding),\n      cursorX: result.cursorX,\n      cursorLine: result.cursorLine,\n      success: true,\n      tabStops: result.tabStops,\n      parenTrails: result.parenTrails\n    };\n    if (result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  else {\n    final = {\n      text: result.partialResult ? result.lines.join(lineEnding) : result.origText,\n      cursorX: result.partialResult ? result.cursorX : result.origCursorX,\n      cursorLine: result.partialResult ? result.cursorLine : result.origCursorLine,\n      parenTrails: result.partialResult ? result.parenTrails : null,\n      success: false,\n      error: result.error\n    };\n    if (result.partialResult && result.returnParens) {\n      final.parens = result.parens;\n    }\n  }\n  if (final.cursorX === UINT_NULL) { delete final.cursorX; }\n  if (final.cursorLine === UINT_NULL) { delete final.cursorLine; }\n  if (final.tabStops && final.tabStops.length === 0) { delete final.tabStops; }\n  return final;\n}\n\nfunction indentMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, INDENT_MODE));\n}\n\nfunction parenMode(text, options) {\n  options = parseOptions(options);\n  return publicResult(processText(text, options, PAREN_MODE));\n}\n\nfunction smartMode(text, options) {\n  options = parseOptions(options);\n  var smart = options.selectionStartLine == null;\n  return publicResult(processText(text, options, INDENT_MODE, smart));\n}\n\nvar API = {\n  version: \"3.12.0\",\n  indentMode: indentMode,\n  parenMode: parenMode,\n  smartMode: smartMode\n};\n\nreturn API;\n\n})); // end module anonymous scope\n\n};"],
"names":["shadow$provide","global","require","module","exports","root","factory","define","amd","parinfer","isInteger","x","isFinite","Math","floor","parseOptions","options","cursorX","cursorLine","prevCursorX","prevCursorLine","selectionStartLine","changes","partialResult","forceBalance","returnParens","initialParenTrail","lineNo","UINT_NULL","startX","endX","openers","clamped","cacheErrorPos","result","errorName","e","inputLineNo","inputX","errorPosCache","error","name","cache","keyLineNo","keyX","parinferError","message","errorMessages","opener","peek","parenStack","ERROR_UNMATCHED_CLOSE_PAREN","ERROR_UNMATCHED_OPEN_PAREN","extra","ERROR_UNCLOSED_PAREN","replaceWithinLine","start","end","replace","line","lines","orig","substring","newLine","dx","length","initLine","indentX","commentX","indentDelta","ERROR_LEADING_CLOSE_PAREN","trackingArgTabStop","trackingIndent","isInStr","arr","idxFromBack","maxIdx","isCloseParen","ch","isValidCloseParen","MATCH_PAREN","isWhitespace","isEscaped","BLANK_SPACE","DOUBLE_SPACE","resetParenTrail","parenTrail","getParentOpenerIndex","i","currOutside","prevOutside","isParent","nextOpener","setMaxIndent","parent","maxChildIndent","maxIndent","rememberParenTrail","trail","concat","shortTrail","parenTrails","push","closer","addIndent","delta","origIndent","newIndent","onIndent","quoteDanger","ERROR_QUOTE_DANGER","INDENT_MODE","mode","parens","index","pop","closeCh","PAREN_MODE","minIndent","val","max","min","makeTabStop","tabStop","argX","processChar","skipChar","smart","change","newEndX","oldEndX","leadingCloseParen","idx","SEMICOLON","parenTrailLength","j","NEWLINE","TAB","isEscaping","isInCode","ERROR_EOL_BACKSLASH","isInComment","children","holdMinX","holdMaxX","holding","releaseCursorHold","origStartX","origEndX","origOpeners","canRemove","inLeadingParenTrail","DOUBLE_QUOTE","ERROR_UNCLOSED_QUOTE","BACKSLASH","state","processText","text","origText","origCursorX","origCursorLine","inputLines","split","LINE_ENDING_REGEX","tabStops","success","Array","isArray","newLines","newText","oldLines","oldText","newEndLineNo","lookupLineNo","lookupX","prevArgX","clamping","newStartX","removeCount","slice","newTrail","spaceCount","ERROR_UNHANDLED","stack","publicResult","search","final","join","lineEnding","API","version","indentMode","parenMode","smartMode"]
}

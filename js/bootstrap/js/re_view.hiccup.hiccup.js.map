{"version":3,"sources":["re_view/hiccup/hiccup.cljs"],"mappings":"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","names":["re-view.hiccup.hiccup/parse-key","x","cljs.core/re-find","p1__26245#","cljs.core.update","cljs.core._EQ_","clojure.string/replace","p1__26246#","cljs.core.subs","re-view.hiccup.hiccup/parse-key-memoized","cljs.core/memoize","re-view.hiccup.hiccup/reduce-flatten-seqs","f","init","coll","cljs.core.reduce","c","cljs.core/seq?","cljs.core.conj","re-view.hiccup.hiccup/parse-args","form","len","cljs.core/count","first-child","cljs.core/PersistentArrayMap","cljs.core/PersistentHashMap","cljs.core.subvec","re-view.hiccup.hiccup/camelCase","s","p__26249","vec__26250","cljs.core.nth","_","clojure.string/upper-case","re-view.hiccup.hiccup/camelCase?","attr-name","cljs.core/not","re-view.hiccup.hiccup/key->react-attr","k","cljs.core/keyword-identical?","k-str","cljs.core/name","G__26255","re-view.hiccup.hiccup/map->js","style","style-js","seq__26260","cljs.core/seq","chunk__26261","count__26262","i__26263","vec__26271","temp__5735__auto__","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","vec__26276","cljs.core/first","cljs.core/next","v","re-view.hiccup.hiccup/concat-classes","k-classes","class","classes","G__26279","cljs.core.into","clojure.string.join","re-view.hiccup.hiccup/*wrap-props*","re-view.hiccup.hiccup/props->js","tag","k-id","props","or__4126__auto__","map__26280","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","class-name","G__26281","cljs.core/boolean","prop-js","G__26291","G__26294","G__26298","seq__26299","chunk__26300","count__26301","i__26302","vec__26310","vec__26316","re-view.hiccup.hiccup/*create-element*","js/module$node_modules$react$index.createElement"],"sourcesContent":["(ns re-view.hiccup.hiccup\n  (:require [clojure.string :as string]\n            [\"react\" :as react]))\n\n(defn parse-key\n  \"Parses a hiccup key like :div#id.class1.class2 to return the tag name, id, and classes.\n   If tag-name is ommitted, defaults to 'div'. Class names are padded with spaces.\"\n  [x]\n  (-> (re-find #\":([^#.]*)(?:#([^.]+))?(.*)?\" (str x))\n      (update 1 #(if (= \"\" %) \"div\" (string/replace % \"/\" \":\")))\n      (update 3 #(when %\n                   (string/replace (subs % 1) \".\" \" \")))))\n\n;; parse-key is an ideal target for memoization, because keyword forms are\n;; frequently reused (eg. in lists) and almost never generated dynamically.\n(def parse-key-memoized (memoize parse-key))\n\n(defn reduce-flatten-seqs\n  \"Recursively apply f to nested vectors, unwrapping seqs. Similar to recursive `mapcat` but returns a vector.\"\n  [f init coll]\n  (reduce (fn my-f [c x]\n            (if (seq? x)\n              (reduce-flatten-seqs f c x)\n              (conj c (f x)))) init coll))\n\n(defn parse-args\n  \"Return props and children for a hiccup form. If the second element is not a map, supplies an empty map as props.\"\n  [form]\n  (let [len (count form)]\n    (cond (= len 1) [{} []]\n          (let [first-child (form 1)]\n            (or (nil? first-child)\n                (instance? PersistentArrayMap first-child)\n                (instance? PersistentHashMap first-child))) [(form 1) (if (> len 2) (subvec form 2 len) [])]\n          :else [{} (subvec form 1 len)])))\n\n(defn ^string camelCase [s]\n  (string/replace s #\"-([a-z])\" (fn [[_ s]] (string/upper-case s))))\n\n(defn ^boolean camelCase?\n  \"CamelCase by default, only exceptions are data- and aria- attributes.\"\n  [attr-name]\n  (not (re-find #\"^(?:data\\-|aria\\-)\" attr-name)))\n\n(defn key->react-attr\n  \"CamelCase react keys, except for aria- and data- attributes\"\n  [k]\n  (if (keyword-identical? k :for)\n    \"htmlFor\"\n    (let [k-str (name k)]\n      (cond-> k-str\n              (camelCase? k-str) (camelCase)))))\n\n(defn map->js\n  \"Return javascript object with camelCase keys. Not recursive.\"\n  [style]\n  (let [style-js (js-obj)]\n    (doseq [[k v] style]\n      (aset style-js (camelCase (name k)) v))\n    style-js))\n\n(defn concat-classes\n  \"Build className from keyword classes, :class and :classes.\"\n  [^js/String k-classes ^js/String class classes]\n  (->> (cond-> []\n               k-classes (conj k-classes)\n               class (conj class)\n               classes (into classes))\n       (string/join \" \")))\n\n(def ^:dynamic *wrap-props* nil)\n\n(defn props->js\n  \"Returns a React-conformant javascript object. An alternative to clj->js,\n  allowing for key renaming without an extra loop through every prop map.\"\n  [tag k-id k-classes props]\n  (when (or props k-id k-classes)\n    (let [{:keys [class class-name classes] :as props} (cond-> props\n                                                               (boolean *wrap-props*)\n                                                               (*wrap-props* tag))\n          prop-js (cond-> (js-obj)\n                          k-id (doto (aset \"id\" k-id))\n                          (or k-classes class class-name classes) (doto (aset \"className\" (concat-classes k-classes (or class class-name) classes))))]\n      (doseq [[k v] props]\n        (cond\n          ;; convert :style and :dangerouslySetInnerHTML to js objects\n          (or (keyword-identical? k :style)\n              (keyword-identical? k :dangerouslySetInnerHTML))\n          (aset prop-js (name k) (map->js v))\n          ;; ignore className-related keys\n          (or (keyword-identical? k :classes)\n              (keyword-identical? k :class)) nil\n          ;; passthrough all other values\n          :else (aset prop-js (key->react-attr k) v)))\n      prop-js)))\n\n\n(def ^:dynamic *create-element* react/createElement)"]}
{
"version":3,
"file":"module$node_modules$three$examples$jsm$math$ConvexHull.js",
"lineCount":23,
"mappings":"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",
"sources":["node_modules/three/examples/jsm/math/ConvexHull.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$examples$jsm$math$ConvexHull\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConvexHull = void 0;\n\nvar _threeModule = require(\"../../../build/three.module.js\");\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n *\n */\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new _threeModule.Vector3();\n\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function setFromPoints(points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n\n      this.makeEmpty();\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n      return this;\n    },\n    setFromObject: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            var vertices = geometry.vertices;\n\n            for (i = 0, l = vertices.length; i < l; i++) {\n              point = vertices[i].clone();\n              point.applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new _threeModule.Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function containsPoint(point) {\n      var faces = this.faces;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    },\n    intersectRay: function intersectRay(ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the ray\u2019s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    },\n    intersectsRay: function intersectsRay(ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function computeExtremes() {\n      var min = new _threeModule.Vector3();\n      var max = new _threeModule.Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new _threeModule.Line3();\n          plane = new _threeModule.Plane();\n          closestPoint = new _threeModule.Vector3();\n        }\n\n        var vertex,\n            vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n            maxDistance = 0;\n        var index = 0;\n\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n\n        var faces = [];\n\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function reindexFaces() {\n      var activeFaces = [];\n\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function nextVertexToAdd() {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function compute() {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new _threeModule.Vector3();\n    this.midpoint = new _threeModule.Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  Object.assign(Face, {\n    create: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function getEdge(i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new _threeModule.Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  Object.assign(HalfEdge.prototype, {\n    head: function head() {\n      return this.vertex;\n    },\n    tail: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function length() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    },\n    lengthSquared: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    },\n    setTwin: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  Object.assign(VertexList.prototype, {\n    first: function first() {\n      return this.head;\n    },\n    last: function last() {\n      return this.tail;\n    },\n    clear: function clear() {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    },\n    isEmpty: function isEmpty() {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\n\nexports.ConvexHull = ConvexHull;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","ConvexHull","_threeModule","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","Vector3","midpoint","constant","area","outside","mark","Visible","edge","HalfEdge","vertex","face","twin","next","prev","VertexNode","point","tail","head","v1","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","computeExtremes","minVertices","maxVertices","j","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","line3","plane","closestPoint","Line3","Plane","extremes","index","v0","set","closestPointToPoint","distanceToSquared","v2","setFromCoplanarPoints","v3","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeFace","eyeVertex","computeHorizon","eyePoint","crossEdge","horizon","Deleted","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","triangle","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"]
}
